import json
import sys
import os

cpp_headers = \
"""/*
* DON'T TOUCH!
* This file is generated by python script AUTOMATICALLY!
*
* Generated base on: {0}
* Type name: {1}
* Tester:    int {1}_tester();
*
* Json keep-word: 
    "default_value_fields": [], # Take value in .json file as the default value of cpp variable
    "optional_fields": [], # Not require to present to .json file, but always in cpp struct
    "assign_type_fields": {{"field":"cpp-type"}}, # Assign specal cpp-type of field, but not infer automatically as default
    "assign_set_lists": [], # Take list in .json file as std::set<>, but not std::vector<> as default
* Script author: ChenZaihui<chinsaiki@outlook.com>
*/
#pragma once
#include <assert.h>
#include "json/json_util.h"
#include "logger/logger.h"

#include <set>
#include <list>
#include <vector>
"""

keep_words = ['default_value_fields', 'optional_fields', 'assign_type_fields', 'assign_set_lists']

def determin_value_type(value):
    if isinstance(value, str):
        return "std::string"
    elif isinstance(value, bool):
        return "bool"
    elif isinstance(value, int):
        return "int"
    elif isinstance(value, float):
        return "double"

def determin_default_value(value):
    if isinstance(value, str):
        return '"%s"' % value
    elif isinstance(value, bool):
        return "true" if value else "false"
    elif isinstance(value, int):
        return "%d" % value
    elif isinstance(value, float):
        return "%.f" % value

def dict_to_struct(cpp_vari, json_vari, name, json_dict, namespace_list = [], json_vari_suffix=''):
    main_str = ["struct {} {{".format(name)]
    from_str = []
    to_str = []
    if 'optional_fields' in json_dict:
        optional_fields = json_dict['optional_fields']
    else:
        optional_fields = []
    if 'default_value_fields' in json_dict:
        default_value_fields = json_dict['default_value_fields']
    else:
        default_value_fields = []
    optional_fields.extend(default_value_fields)    # field with default value is always optional field

    if 'assign_type_fields' in json_dict:
        assign_type_fields = json_dict['assign_type_fields']
        print("use assign_type_fields = {}".format(assign_type_fields))
    else:
        assign_type_fields = {}

    if 'assign_set_lists' in json_dict:
        assign_set_lists = json_dict['assign_set_lists']
        print("use assign_set_lists = {}".format(assign_set_lists))
    else:
        assign_set_lists = []
    
        
    for key_name in json_dict:
        if key_name in keep_words:
            continue

        key_value = json_dict[key_name]
        # if key_value is None:
        #     key_type = 'bool'
        #     key_name = key_name + "_is_null"
        #     main_str.append("\t{} {};\t//\t{}".format(key_type, key_name, key_value))

        #     from_str.append('{0}.{2} = {1}{3}["{2}"].is_null();'.format(cpp_vari, json_vari, key_name, json_vari_suffix))
        # el
        if isinstance(key_value, (str, int, float, bool)):
            if key_name in assign_type_fields:
                key_type = assign_type_fields[key_name]
                print("use assigned type %s = %s" % (key_name, key_type) )
            else:
                key_type = determin_value_type(key_value)
            
            if key_name in default_value_fields:
                main_str.append("\t{} {} = {};".format(key_type, key_name, determin_default_value(key_value)))
            else:
                main_str.append("\t{} {};\t//\t{}".format(key_type, key_name, key_value))

            from_str.append('try{')
            from_str.append('\t{0}.{2} = {1}{4}.at("{2}").get<{3}>();'.format(cpp_vari, json_vari, key_name, key_type, json_vari_suffix))
            if key_name not in optional_fields:
                from_str.append("}catch(const std::exception& e){")
                from_str.append('\tERR("{{:}} not found in json! e={{:}}", "{}", e.what());'.format(key_name))
                from_str.append('\tthrow e;')
            else:
                from_str.append("}catch(...){")
            from_str.append("}")

            to_str.append('{}["{}"] = {}.{};'.format(json_vari, key_name, cpp_vari, key_name))
        elif isinstance(key_value, dict):
            sub_json_vari = json_vari+"_"+key_name
            sub_type = key_name+"_t"
            sub_str, sub_from, sub_to = dict_to_struct(cpp_vari+"."+key_name, sub_json_vari, sub_type, key_value, namespace_list+[sub_type])

            sub_str = ["\t"+x for x in sub_str]
            sub_str.append("\t{}_t {};".format(key_name, key_name))
            main_str.extend(sub_str)

            from_str.append('const json& {} = {}{}["{}"];'.format(sub_json_vari, json_vari, json_vari_suffix, key_name))
            from_str.extend(sub_from)

            to_str.append('json {};'.format(sub_json_vari))
            to_str.extend(sub_to)
            to_str.append('{}["{}"] = {};'.format(json_vari, key_name, sub_json_vari))
        elif isinstance(key_value, list):
            if len(key_value)==0:
                print("unable to determin type of list({}:{})".format(key_name, key_value))
            else:
                key_value = key_value[0]
                if isinstance(key_value, (str, int, float, bool) or key_name in assign_type_fields):
                    sub_json_vari = json_vari+"_"+key_name

                    if key_name in assign_type_fields:
                        key_type = assign_type_fields[key_name]
                        print("use assigned type %s = std::vector<%s>" % (key_name, key_type) )
                    else:
                        key_type = determin_value_type(key_value)

                    if key_name in assign_set_lists:
                        main_str.append("\tstd::set<{}> {};\t//\t{}".format(key_type, key_name, key_value))
                    else:
                        main_str.append("\tstd::vector<{}> {};\t//\t{}".format(key_type, key_name, key_value))
                    
                    sub_str = []
                    sub_str.append('try{')
                    sub_str.append('\tconst json& {} = {}{}.at("{}");'.format(sub_json_vari, json_vari, json_vari_suffix, key_name))
                    sub_str.append('\tfor(auto& {0}_x: {0}.items()){{'.format(sub_json_vari))
                    if key_name in assign_set_lists:
                        sub_str.append('\t\t{}.{}.insert({}_x.value().get<{}>());'.format(cpp_vari, key_name, sub_json_vari, key_type))
                    else:
                        sub_str.append('\t\t{}.{}.push_back({}_x.value().get<{}>());'.format(cpp_vari, key_name, sub_json_vari, key_type))
                    sub_str.append('\t}')
                    if key_name not in optional_fields:
                        sub_str.append("}catch(const std::exception& e){")
                        sub_str.append('\tERR("parse field {{:}} fail! e={{:}}", "{}", e.what());'.format(key_name))
                        sub_str.append('\tthrow e;')
                    else:
                        sub_str.append("}catch(...){")
                    sub_str.append("}")


                    from_str.extend(sub_str)

                    to_str.append('{}["{}"] = {}.{};'.format(json_vari, key_name, cpp_vari, key_name))
                elif isinstance(key_value, dict):
                    sub_json_vari = json_vari+"_"+key_name
                    sub_cpp_vari = cpp_vari.replace('.', '_')+"_"+key_name
                    sub_type = key_name+"_t"
                    sub_str, sub_from, sub_to = dict_to_struct(sub_cpp_vari, sub_json_vari, sub_type, key_value, namespace_list+[sub_type], ".value()")

                    sub_str = ["\t"+x for x in sub_str]
                    main_str.extend(sub_str)
                    main_str.append("\tstd::vector<{}::{}> {};".format("::".join(namespace_list), key_name+"_t", key_name))

                    sub_str = []
                    sub_str.append('try{')
                    sub_str.append('\tconst json& {0} = {1}{3}.at("{2}");'.format(sub_json_vari, json_vari, key_name, json_vari_suffix))
                    sub_str.append('\tfor(auto& {0}_x: {0}.items()){{'.format(sub_json_vari))
                    sub_str.append('\t\t{}::{} {};'.format("::".join(namespace_list), sub_type, sub_cpp_vari))
                    sub_from = ["\t\t"+x for x in sub_from]
                    sub_from = [x.replace(sub_json_vari, sub_json_vari+'_x') for x in sub_from]
                    sub_str.extend(sub_from)
                    sub_str.append('\t\t{}.{}.emplace_back({});'.format(cpp_vari, key_name, sub_cpp_vari))
                    sub_str.append('\t}')
                    if key_name not in optional_fields:
                        sub_str.append("}catch(const std::exception& e){")
                        sub_str.append('\tERR("parse field {{:}} fail! e={{:}}", "{}", e.what());'.format(key_name))
                        sub_str.append('\tthrow e;')
                    else:
                        sub_str.append("}catch(...){")
                    sub_str.append("}")

                    from_str.extend(sub_str)

                    sub_str = []
                    sub_str.append('{}["{}"] = json();'.format(json_vari, key_name))
                    sub_str.append('for(const auto& {}_x: {}.{}){{'.format(sub_cpp_vari, cpp_vari, key_name))
                    sub_str.append('\tjson {};'.format(sub_json_vari))
                    sub_to = ["\t"+x for x in sub_to]
                    sub_to = [x.replace(sub_cpp_vari, sub_cpp_vari+'_x') for x in sub_to]
                    sub_str.extend(sub_to)
                    sub_str.append('\t{}["{}"].push_back({});'.format(json_vari, key_name, sub_json_vari))
                    sub_str.append('}')

                    to_str.extend(sub_str)
                else:
                    print("unsupported list type for {}:{}".format(key_name, key_value))
                    exit(-1)
        else:
            print("unsupported type for {}:{}".format(key_name, key_value))
            exit(-1)

    main_str.append("};")
    return main_str, from_str, to_str







print("Current working path={}".format(os.getcwd()))

if len(sys.argv)==1:
    print("Need at least 1 arg:")
    print("  {} <json file>  [<output file>]".format(sys.argv[0]))
    exit(1)

src_json = sys.argv[1]
if len(sys.argv)>=3:
    tgt_cpp = sys.argv[2]
else:
    tgt_cpp = src_json.replace(".json", ".h")


print("reading json file:{}".format(src_json))
with open(src_json, 'r', encoding='UTF-8') as f:
    text = f.readlines()
# print(text)
text = "".join(text)
json_instance = json.loads(text)

# print("read json OK:\n{}".format(json.dumps(json_instance, indent=4, separators=(',', ': '))))

print("read json base type={}".format(type(json_instance)))
if not isinstance(json_instance, dict):
    print("error:only support base type==dict for now!")
    exit(0)

type_name = os.path.basename(src_json)
type_name = type_name.split(".")[0]
print("Creating Cpp file for type={}".format(type_name))

cpp_v = type_name + "_var"
json_v = "json_var"
cpp_struct, cpp_from_str, cpp_to_str = dict_to_struct(cpp_v, json_v, type_name, json_instance, [type_name])
output = []

cpp_headers = cpp_headers.format(src_json, type_name)
output.append(cpp_headers)

output.append("namespace YY {\n")

print("/* type */")
output.append("/* type */")
cpp_struct = "\n".join(cpp_struct)
# print(cpp_struct)
output.append(cpp_struct[:-2])

print("/* from json */")
output.append("\t/* from json */")
cpp_from = ['\tstatic bool from_json(const json& {}, {}& {}){{'.format(json_v, type_name, cpp_v)]
cpp_from.append("\t\ttry{")
cpp_from_str = ['\t\t\t'+x for x in cpp_from_str]
cpp_from.extend(cpp_from_str)
cpp_from.append("\t\t}catch (const std::exception& e){")
cpp_from.append('\t\t\tERR("parse json {{:}} \\nfail:{{:}}", {}.dump(4), e.what());'.format(json_v))
cpp_from.append("\t\t\treturn false;")
cpp_from.append("\t\t}")
cpp_from.append("\t\treturn true;")
cpp_from.append("\t}")
cpp_from = "\n".join(cpp_from)
# print(cpp_from)
output.append(cpp_from)

print("/* to json */")
output.append("\t/* to json */")
cpp_to = ['\tstatic bool to_json(json& {}, const {}& {}){{'.format(json_v, type_name, cpp_v)]
cpp_to.append("\t\ttry{")
cpp_to_str = ['\t\t\t'+x for x in cpp_to_str]
cpp_to.extend(cpp_to_str)
cpp_to.append("\t\t}catch (const std::exception& e){")
cpp_to.append('\t\tERR("to json {{:}} \\nfail:{{:}}", {}.dump(4), e.what());'.format(json_v))
cpp_to.append("\t\t\treturn false;")
cpp_to.append("\t\t}")
cpp_to.append("\t\treturn true;")
cpp_to.append("\t}")
cpp_to = "\n".join(cpp_to)
# print(cpp_to)
output.append(cpp_to)

output.append("}};// struct {}".format(type_name))

output.append("} // namespace YY")

cpp_json_text = text.replace('"', '\\"').replace("\n","").replace("\r","")
test_source = """

/* Tester */
inline int {3}_tester() {{

    //std::ifstream i("{0}/{1}");
    std::string i("{5}");
    YY::json {2};
    //i >> {2}; //from file
    {2} = YY::json::parse(i);  //from string

    YY::{3} {4};

    if(!YY::{3}::from_json({2}, {4})){{
        INFO("YY::{3}::from_json fail!");
        return -1;
    }}

    YY::json j_out;
    if(!YY::{3}::to_json(j_out, {4})){{
        INFO("YY::{3}::to_json fail!");
        return -1;
    }}

    INFO("{{:}}", j_out.dump(4));

    return 0;
}}

""".format(os.getcwd().replace("\\", "/"), 
src_json.replace("\\", "/"), 
json_v,
type_name, cpp_v,
cpp_json_text
)
# print(test_source)
output.append(test_source)

output = '\n'.join(output)
if tgt_cpp is not None:
    with open(tgt_cpp, 'w+') as fo:
        fo.write(output)

print("output cpp .h = {}".format(tgt_cpp))