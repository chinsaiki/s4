/*
* DON'T TOUCH!
* This file is generated by python script AUTOMATICALLY!
*
* Generated base on: ./json_template\s3_order_t.json
* Type name: s3_order_t
* Tester:    int s3_order_t_tester();
*
* Json keep-word: 
    "__default_value_fields__": [], # Take value in .json file as the default value of cpp variable
    "__optional_fields__": [], # Not require to present to .json file, but always in cpp struct
    "__assign_type_fields__": {"field":"cpp-type"}, # Assign specal cpp-type of field, but not infer automatically as default.
    "__assign_enum_fields__": {"field":"enum-type"}, # Assign specal enum-type of field, but not infer automatically as default.
                              enum-type need have implemented <enum-type>_toSting() & <enum-type>_fromString() functions.
    "__assign_set_lists__": [], # Take list in .json file as std::set<>, but not std::vector<> as default
    "__cpp_eq_eclude__":[],     # List of variables not involved in equal compare.
    "__comment__xxx":"", # Add comment line
    "__sqlite_capable__":"", # enable sqlite tableIO autogen
    "__sqlite_primary__":"", # assign the primary key of sqlite, if not assigned, first existing col of [ 'id', 'date', 'mktCode', 'datetime', 'code'] will be assigned automatically.
* Script author: ChinSaiki<chinsaiki@outlook.com>
*/
#pragma once


#include <assert.h>
#include "common/s4json_util.h"
#include "common/s4logger.h"
#include "types/s4type.h"
#include "types/s4convertors.h"

#include <set>
#include <list>
#include <vector>

namespace S4 {

/* type */
struct s3_order_t {
	std::string StgName;	//	
	int64_t ID;	//	1
	std::string InsName;	//	
	time_utcSec_t time;	//	0
	std::string optType;	//	
	std::string status;	//	
	int open;	//	-1
	int take;	//	-1
	int stop;	//	-1
	int close;	//	-1
	int openA;	//	-1
	int closeA;	//	-1
	std::string datetime;	//	

	/* from json */
	static bool from_json(const nlohmann::json& json_var, s3_order_t& s3_order_t_var){
		try{
			if(json_var.find("StgName") != json_var.end()){
				try{
					const auto& json_var_StgName = json_var.at("StgName");
					json_var_StgName.get_to(s3_order_t_var.StgName);
				}catch(const std::exception& e){
					ERR("Convert \"StgName\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"StgName\" not found in json!");
				return false;
			}
			if(json_var.find("ID") != json_var.end()){
				try{
					const auto& json_var_ID = json_var.at("ID");
					if (json_var_ID.is_string())
					    s3_order_t_var.ID = IntConvertor::convert(json_var_ID.get<std::string>());
					else
					    json_var_ID.get_to(s3_order_t_var.ID);
				}catch(const std::exception& e){
					ERR("Convert \"ID\" to \"int64_t\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"ID\" not found in json!");
				return false;
			}
			if(json_var.find("InsName") != json_var.end()){
				try{
					const auto& json_var_InsName = json_var.at("InsName");
					json_var_InsName.get_to(s3_order_t_var.InsName);
				}catch(const std::exception& e){
					ERR("Convert \"InsName\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"InsName\" not found in json!");
				return false;
			}
			if(json_var.find("time") != json_var.end()){
				try{
					const auto& json_var_time = json_var.at("time");
					json_var_time.get_to(s3_order_t_var.time);
				}catch(const std::exception& e){
					ERR("Convert \"time\" to \"time_utcSec_t\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"time\" not found in json!");
				return false;
			}
			if(json_var.find("optType") != json_var.end()){
				try{
					const auto& json_var_optType = json_var.at("optType");
					json_var_optType.get_to(s3_order_t_var.optType);
				}catch(const std::exception& e){
					ERR("Convert \"optType\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"optType\" not found in json!");
				return false;
			}
			if(json_var.find("status") != json_var.end()){
				try{
					const auto& json_var_status = json_var.at("status");
					json_var_status.get_to(s3_order_t_var.status);
				}catch(const std::exception& e){
					ERR("Convert \"status\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"status\" not found in json!");
				return false;
			}
			if(json_var.find("open") != json_var.end()){
				try{
					const auto& json_var_open = json_var.at("open");
					if (json_var_open.is_string())
					    s3_order_t_var.open = IntConvertor::convert(json_var_open.get<std::string>());
					else
					    json_var_open.get_to(s3_order_t_var.open);
				}catch(const std::exception& e){
					ERR("Convert \"open\" to \"int\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"open\" not found in json!");
				return false;
			}
			if(json_var.find("take") != json_var.end()){
				try{
					const auto& json_var_take = json_var.at("take");
					if (json_var_take.is_string())
					    s3_order_t_var.take = IntConvertor::convert(json_var_take.get<std::string>());
					else
					    json_var_take.get_to(s3_order_t_var.take);
				}catch(const std::exception& e){
					ERR("Convert \"take\" to \"int\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"take\" not found in json!");
				return false;
			}
			if(json_var.find("stop") != json_var.end()){
				try{
					const auto& json_var_stop = json_var.at("stop");
					if (json_var_stop.is_string())
					    s3_order_t_var.stop = IntConvertor::convert(json_var_stop.get<std::string>());
					else
					    json_var_stop.get_to(s3_order_t_var.stop);
				}catch(const std::exception& e){
					ERR("Convert \"stop\" to \"int\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"stop\" not found in json!");
				return false;
			}
			if(json_var.find("close") != json_var.end()){
				try{
					const auto& json_var_close = json_var.at("close");
					if (json_var_close.is_string())
					    s3_order_t_var.close = IntConvertor::convert(json_var_close.get<std::string>());
					else
					    json_var_close.get_to(s3_order_t_var.close);
				}catch(const std::exception& e){
					ERR("Convert \"close\" to \"int\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"close\" not found in json!");
				return false;
			}
			if(json_var.find("openA") != json_var.end()){
				try{
					const auto& json_var_openA = json_var.at("openA");
					if (json_var_openA.is_string())
					    s3_order_t_var.openA = IntConvertor::convert(json_var_openA.get<std::string>());
					else
					    json_var_openA.get_to(s3_order_t_var.openA);
				}catch(const std::exception& e){
					ERR("Convert \"openA\" to \"int\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"openA\" not found in json!");
				return false;
			}
			if(json_var.find("closeA") != json_var.end()){
				try{
					const auto& json_var_closeA = json_var.at("closeA");
					if (json_var_closeA.is_string())
					    s3_order_t_var.closeA = IntConvertor::convert(json_var_closeA.get<std::string>());
					else
					    json_var_closeA.get_to(s3_order_t_var.closeA);
				}catch(const std::exception& e){
					ERR("Convert \"closeA\" to \"int\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"closeA\" not found in json!");
				return false;
			}
			if(json_var.find("datetime") != json_var.end()){
				try{
					const auto& json_var_datetime = json_var.at("datetime");
					json_var_datetime.get_to(s3_order_t_var.datetime);
				}catch(const std::exception& e){
					ERR("Convert \"datetime\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"datetime\" not found in json!");
				return false;
			}
		}catch (const std::exception& e){
			ERR("parse json {:} \nfail:{:}", json_var.dump(4), e.what());
			return false;
		}
		return true;
	}
	/* to json */
	static bool to_json(nlohmann::json& json_var, const s3_order_t& s3_order_t_var){
		try{
			json_var["StgName"] = s3_order_t_var.StgName;
			json_var["ID"] = s3_order_t_var.ID;
			json_var["InsName"] = s3_order_t_var.InsName;
			json_var["time"] = s3_order_t_var.time;
			json_var["optType"] = s3_order_t_var.optType;
			json_var["status"] = s3_order_t_var.status;
			json_var["open"] = s3_order_t_var.open;
			json_var["take"] = s3_order_t_var.take;
			json_var["stop"] = s3_order_t_var.stop;
			json_var["close"] = s3_order_t_var.close;
			json_var["openA"] = s3_order_t_var.openA;
			json_var["closeA"] = s3_order_t_var.closeA;
			json_var["datetime"] = s3_order_t_var.datetime;
		}catch (const std::exception& e){
		ERR("to json {:} \nfail:{:}", json_var.dump(4), e.what());
			return false;
		}
		return true;
	}

	bool operator ==(const s3_order_t& d) const
	{
		if (StgName == d.StgName &&
			ID == d.ID &&
			InsName == d.InsName &&
			time == d.time &&
			optType == d.optType &&
			status == d.status &&
			open == d.open &&
			take == d.take &&
			stop == d.stop &&
			close == d.close &&
			openA == d.openA &&
			closeA == d.closeA &&
			datetime == d.datetime)
		{
			return true;
		}
		return false;
	}

	bool operator !=(const s3_order_t& d) const
	{
		return !((*this)==d);
	}

};// struct s3_order_t
} // namespace S4


        /* Tester */
        inline int s3_order_t_tester() {

            //std::ifstream i("G:/work2t/99_s3/s4/./json_template/s3_order_t.json");
            std::string i("{    \"__sqlite_capable__\" : true,    \"__sqlite_primary__\" : \"ID, time, status\",    \"__assign_type_fields__\": {        \"time\":\"time_utcSec_t\",         \"ID\":\"int64_t\"    },    \"StgName\":\"\",	\"ID\":1,	\"InsName\":\"\",	\"time\":0,	\"optType\":\"\",	\"status\":\"\",	\"open\":-1,	\"take\":-1,	\"stop\":-1,	\"close\":-1,	\"openA\":-1,	\"closeA\":-1,	\"datetime\":\"\"}");
            nlohmann::json json_var;
            //i >> json_var; //from file
            json_var = nlohmann::json::parse(i);  //from string

            S4::s3_order_t s3_order_t_var;

            if(!S4::s3_order_t::from_json(json_var, s3_order_t_var)){
                INFO("S4::s3_order_t::from_json fail!");
                return -1;
            }

            nlohmann::json j_out;
            if(!S4::s3_order_t::to_json(j_out, s3_order_t_var)){
                INFO("S4::s3_order_t::to_json fail!");
                return -1;
            }

            INFO("{:}", j_out.dump(4));

            return 0;
        }

        