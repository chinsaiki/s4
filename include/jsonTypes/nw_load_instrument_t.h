/*
* DON'T TOUCH!
* This file is generated by python script AUTOMATICALLY!
*
* Generated base on: ./json_template\nw_load_instrument_t.json
* Type name: nw_load_instrument_t
* Tester:    int nw_load_instrument_t_tester();
*
* Json keep-word: 
    "__default_value_fields__": [], # Take value in .json file as the default value of cpp variable
    "__optional_fields__": [], # Not require to present to .json file, but always in cpp struct
    "__assign_type_fields__": {"field":"cpp-type"}, # Assign specal cpp-type of field, but not infer automatically as default.
    "__assign_enum_fields__": {"field":"enum-type"}, # Assign specal enum-type of field, but not infer automatically as default.
                              enum-type need have implemented <enum-type>_toSting() & <enum-type>_fromString() functions.
    "__assign_set_lists__": [], # Take list in .json file as std::set<>, but not std::vector<> as default
    "__cpp_eq_eclude__":[],     # List of variables not involved in equal compare.
    "__comment__xxx":"", # Add comment line
    "__sqlite_capable__":"", # enable sqlite tableIO autogen
    "__sqlite_primary__":"", # assign the primary key of sqlite, if not assigned, first existing col of [ 'id', 'date', 'mktCode', 'datetime', 'code'] will be assigned automatically.
* Script author: ChinSaiki<chinsaiki@outlook.com>
*/
#pragma once


#include <assert.h>
#include "common/s4json_util.h"
#include "common/s4logger.h"
#include "types/s4type.h"
#include "types/s4convertors.h"

#include <set>
#include <list>
#include <vector>

namespace S4 {

/* type */
struct nw_load_instrument_t {
	int command = (int)1;
	int seq;	//	0
	std::string mktCode;	//	sz002810
	std::string stgName;	//	tdx_xyzq_history
	std::string tableName;	//	to20200531

	/* from json */
	static bool from_json(const nlohmann::json& json_var, nw_load_instrument_t& nw_load_instrument_t_var){
		try{
			if(json_var.find("command") != json_var.end()){
				try{
					const auto& json_var_command = json_var.at("command");
					if (json_var_command.is_string())
					    nw_load_instrument_t_var.command = IntConvertor::convert(json_var_command.get<std::string>());
					else
					    json_var_command.get_to(nw_load_instrument_t_var.command);
				}catch(const std::exception& e){
					ERR("Convert \"command\" to \"int\" fail! e={:}", e.what());
					throw e;
				}
			}
			if(json_var.find("seq") != json_var.end()){
				try{
					const auto& json_var_seq = json_var.at("seq");
					if (json_var_seq.is_string())
					    nw_load_instrument_t_var.seq = IntConvertor::convert(json_var_seq.get<std::string>());
					else
					    json_var_seq.get_to(nw_load_instrument_t_var.seq);
				}catch(const std::exception& e){
					ERR("Convert \"seq\" to \"int\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"seq\" not found in json!");
				return false;
			}
			if(json_var.find("mktCode") != json_var.end()){
				try{
					const auto& json_var_mktCode = json_var.at("mktCode");
					json_var_mktCode.get_to(nw_load_instrument_t_var.mktCode);
				}catch(const std::exception& e){
					ERR("Convert \"mktCode\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"mktCode\" not found in json!");
				return false;
			}
			if(json_var.find("stgName") != json_var.end()){
				try{
					const auto& json_var_stgName = json_var.at("stgName");
					json_var_stgName.get_to(nw_load_instrument_t_var.stgName);
				}catch(const std::exception& e){
					ERR("Convert \"stgName\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}
			if(json_var.find("tableName") != json_var.end()){
				try{
					const auto& json_var_tableName = json_var.at("tableName");
					json_var_tableName.get_to(nw_load_instrument_t_var.tableName);
				}catch(const std::exception& e){
					ERR("Convert \"tableName\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}
		}catch (const std::exception& e){
			ERR("parse json {:} \nfail:{:}", json_var.dump(4), e.what());
			return false;
		}
		return true;
	}
	/* to json */
	static bool to_json(nlohmann::json& json_var, const nw_load_instrument_t& nw_load_instrument_t_var){
		try{
			json_var["command"] = nw_load_instrument_t_var.command;
			json_var["seq"] = nw_load_instrument_t_var.seq;
			json_var["mktCode"] = nw_load_instrument_t_var.mktCode;
			json_var["stgName"] = nw_load_instrument_t_var.stgName;
			json_var["tableName"] = nw_load_instrument_t_var.tableName;
		}catch (const std::exception& e){
		ERR("to json {:} \nfail:{:}", json_var.dump(4), e.what());
			return false;
		}
		return true;
	}

	bool operator ==(const nw_load_instrument_t& d) const
	{
		if (command == d.command &&
			seq == d.seq &&
			mktCode == d.mktCode &&
			stgName == d.stgName &&
			tableName == d.tableName)
		{
			return true;
		}
		return false;
	}

	bool operator !=(const nw_load_instrument_t& d) const
	{
		return !((*this)==d);
	}

};// struct nw_load_instrument_t
} // namespace S4


        /* Tester */
        inline int nw_load_instrument_t_tester() {

            //std::ifstream i("G:/work2t/99_s3/s4/./json_template/nw_load_instrument_t.json");
            std::string i("{    \"__optional_fields__\":[        \"stgName\",        \"tableName\"    ],    \"__default_value_fields__\":[        \"command\"    ],    \"command\" : 1,    \"seq\"     : 0,    \"mktCode\" : \"sz002810\",    \"stgName\" : \"tdx_xyzq_history\",    \"tableName\": \"to20200531\"}");
            nlohmann::json json_var;
            //i >> json_var; //from file
            json_var = nlohmann::json::parse(i);  //from string

            S4::nw_load_instrument_t nw_load_instrument_t_var;

            if(!S4::nw_load_instrument_t::from_json(json_var, nw_load_instrument_t_var)){
                INFO("S4::nw_load_instrument_t::from_json fail!");
                return -1;
            }

            nlohmann::json j_out;
            if(!S4::nw_load_instrument_t::to_json(j_out, nw_load_instrument_t_var)){
                INFO("S4::nw_load_instrument_t::to_json fail!");
                return -1;
            }

            INFO("{:}", j_out.dump(4));

            return 0;
        }

        