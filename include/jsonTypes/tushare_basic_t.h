/*
* DON'T TOUCH!
* This file is generated by python script AUTOMATICALLY!
*
* Generated base on: ./json_template\tushare_basic_t.json
* Type name: tushare_basic_t
* Tester:    int tushare_basic_t_tester();
*
* Json keep-word: 
    "__default_value_fields__": [], # Take value in .json file as the default value of cpp variable
    "__optional_fields__": [], # Not require to present to .json file, but always in cpp struct
    "__assign_type_fields__": {"field":"cpp-type"}, # Assign specal cpp-type of field, but not infer automatically as default.
    "__assign_enum_fields__": {"field":"enum-type"}, # Assign specal enum-type of field, but not infer automatically as default.
                              enum-type need have implemented <enum-type>_toSting() & <enum-type>_fromString() functions.
    "__assign_set_lists__": [], # Take list in .json file as std::set<>, but not std::vector<> as default
    "__cpp_eq_eclude__":[],     # List of variables not involved in equal compare.
    "__comment__xxx":"", # Add comment line
    "__sqlite_capable__":"", # enable sqlite tableIO autogen
    "__sqlite_primary__":"", # assign the primary key of sqlite, if not assigned, first existing col of [ 'id', 'date', 'mktCode', 'datetime', 'code'] will be assigned automatically.
* Script author: ChinSaiki<chinsaiki@outlook.com>
*/
#pragma once


#include <assert.h>
#include "common/s4json_util.h"
#include "common/s4logger.h"
#include "types/s4type.h"
#include "types/s4convertors.h"

#include <set>
#include <list>
#include <vector>

namespace S4 {

/* type */
struct tushare_basic_t {
	pureCodeI_t code;	//	600001
	std::string name;	//	
	std::string industry;	//	
	std::string area;	//	
	double pe;	//	0.0
	double outstanding;	//	0.0
	double totals;	//	0.0
	double totalAssets;	//	0.0
	double liquidAssets;	//	0.0
	double fixedAssets;	//	0.0
	double reserved;	//	0.0
	double reservedPerShare;	//	0.0
	double esp;	//	0.0
	double bvps;	//	0.0
	double pb;	//	0.0
	time_date_t timeToMarket;	//	0
	double undp;	//	0.0
	double perundp;	//	0.0
	double rev;	//	0.0
	double profit;	//	0.0
	double gpr;	//	0.0
	double npr;	//	0.0
	int holders;	//	0

	/* from json */
	static bool from_json(const nlohmann::json& json_var, tushare_basic_t& tushare_basic_t_var){
		try{
			if(json_var.find("code") != json_var.end()){
				try{
					const auto& json_var_code = json_var.at("code");
					json_var_code.get_to(tushare_basic_t_var.code);
				}catch(const std::exception& e){
					ERR("Convert \"code\" to \"pureCodeI_t\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"code\" not found in json!");
				return false;
			}
			if(json_var.find("name") != json_var.end()){
				try{
					const auto& json_var_name = json_var.at("name");
					json_var_name.get_to(tushare_basic_t_var.name);
				}catch(const std::exception& e){
					ERR("Convert \"name\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"name\" not found in json!");
				return false;
			}
			if(json_var.find("industry") != json_var.end()){
				try{
					const auto& json_var_industry = json_var.at("industry");
					json_var_industry.get_to(tushare_basic_t_var.industry);
				}catch(const std::exception& e){
					ERR("Convert \"industry\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"industry\" not found in json!");
				return false;
			}
			if(json_var.find("area") != json_var.end()){
				try{
					const auto& json_var_area = json_var.at("area");
					json_var_area.get_to(tushare_basic_t_var.area);
				}catch(const std::exception& e){
					ERR("Convert \"area\" to \"std::string\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"area\" not found in json!");
				return false;
			}
			if(json_var.find("pe") != json_var.end()){
				try{
					const auto& json_var_pe = json_var.at("pe");
					if (json_var_pe.is_string())
					    tushare_basic_t_var.pe = DoubleConvertor::convert(json_var_pe.get<std::string>());
					else
					    json_var_pe.get_to(tushare_basic_t_var.pe);
				}catch(const std::exception& e){
					ERR("Convert \"pe\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"pe\" not found in json!");
				return false;
			}
			if(json_var.find("outstanding") != json_var.end()){
				try{
					const auto& json_var_outstanding = json_var.at("outstanding");
					if (json_var_outstanding.is_string())
					    tushare_basic_t_var.outstanding = DoubleConvertor::convert(json_var_outstanding.get<std::string>());
					else
					    json_var_outstanding.get_to(tushare_basic_t_var.outstanding);
				}catch(const std::exception& e){
					ERR("Convert \"outstanding\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"outstanding\" not found in json!");
				return false;
			}
			if(json_var.find("totals") != json_var.end()){
				try{
					const auto& json_var_totals = json_var.at("totals");
					if (json_var_totals.is_string())
					    tushare_basic_t_var.totals = DoubleConvertor::convert(json_var_totals.get<std::string>());
					else
					    json_var_totals.get_to(tushare_basic_t_var.totals);
				}catch(const std::exception& e){
					ERR("Convert \"totals\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"totals\" not found in json!");
				return false;
			}
			if(json_var.find("totalAssets") != json_var.end()){
				try{
					const auto& json_var_totalAssets = json_var.at("totalAssets");
					if (json_var_totalAssets.is_string())
					    tushare_basic_t_var.totalAssets = DoubleConvertor::convert(json_var_totalAssets.get<std::string>());
					else
					    json_var_totalAssets.get_to(tushare_basic_t_var.totalAssets);
				}catch(const std::exception& e){
					ERR("Convert \"totalAssets\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"totalAssets\" not found in json!");
				return false;
			}
			if(json_var.find("liquidAssets") != json_var.end()){
				try{
					const auto& json_var_liquidAssets = json_var.at("liquidAssets");
					if (json_var_liquidAssets.is_string())
					    tushare_basic_t_var.liquidAssets = DoubleConvertor::convert(json_var_liquidAssets.get<std::string>());
					else
					    json_var_liquidAssets.get_to(tushare_basic_t_var.liquidAssets);
				}catch(const std::exception& e){
					ERR("Convert \"liquidAssets\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"liquidAssets\" not found in json!");
				return false;
			}
			if(json_var.find("fixedAssets") != json_var.end()){
				try{
					const auto& json_var_fixedAssets = json_var.at("fixedAssets");
					if (json_var_fixedAssets.is_string())
					    tushare_basic_t_var.fixedAssets = DoubleConvertor::convert(json_var_fixedAssets.get<std::string>());
					else
					    json_var_fixedAssets.get_to(tushare_basic_t_var.fixedAssets);
				}catch(const std::exception& e){
					ERR("Convert \"fixedAssets\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"fixedAssets\" not found in json!");
				return false;
			}
			if(json_var.find("reserved") != json_var.end()){
				try{
					const auto& json_var_reserved = json_var.at("reserved");
					if (json_var_reserved.is_string())
					    tushare_basic_t_var.reserved = DoubleConvertor::convert(json_var_reserved.get<std::string>());
					else
					    json_var_reserved.get_to(tushare_basic_t_var.reserved);
				}catch(const std::exception& e){
					ERR("Convert \"reserved\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"reserved\" not found in json!");
				return false;
			}
			if(json_var.find("reservedPerShare") != json_var.end()){
				try{
					const auto& json_var_reservedPerShare = json_var.at("reservedPerShare");
					if (json_var_reservedPerShare.is_string())
					    tushare_basic_t_var.reservedPerShare = DoubleConvertor::convert(json_var_reservedPerShare.get<std::string>());
					else
					    json_var_reservedPerShare.get_to(tushare_basic_t_var.reservedPerShare);
				}catch(const std::exception& e){
					ERR("Convert \"reservedPerShare\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"reservedPerShare\" not found in json!");
				return false;
			}
			if(json_var.find("esp") != json_var.end()){
				try{
					const auto& json_var_esp = json_var.at("esp");
					if (json_var_esp.is_string())
					    tushare_basic_t_var.esp = DoubleConvertor::convert(json_var_esp.get<std::string>());
					else
					    json_var_esp.get_to(tushare_basic_t_var.esp);
				}catch(const std::exception& e){
					ERR("Convert \"esp\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"esp\" not found in json!");
				return false;
			}
			if(json_var.find("bvps") != json_var.end()){
				try{
					const auto& json_var_bvps = json_var.at("bvps");
					if (json_var_bvps.is_string())
					    tushare_basic_t_var.bvps = DoubleConvertor::convert(json_var_bvps.get<std::string>());
					else
					    json_var_bvps.get_to(tushare_basic_t_var.bvps);
				}catch(const std::exception& e){
					ERR("Convert \"bvps\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"bvps\" not found in json!");
				return false;
			}
			if(json_var.find("pb") != json_var.end()){
				try{
					const auto& json_var_pb = json_var.at("pb");
					if (json_var_pb.is_string())
					    tushare_basic_t_var.pb = DoubleConvertor::convert(json_var_pb.get<std::string>());
					else
					    json_var_pb.get_to(tushare_basic_t_var.pb);
				}catch(const std::exception& e){
					ERR("Convert \"pb\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"pb\" not found in json!");
				return false;
			}
			if(json_var.find("timeToMarket") != json_var.end()){
				try{
					const auto& json_var_timeToMarket = json_var.at("timeToMarket");
					json_var_timeToMarket.get_to(tushare_basic_t_var.timeToMarket);
				}catch(const std::exception& e){
					ERR("Convert \"timeToMarket\" to \"time_date_t\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"timeToMarket\" not found in json!");
				return false;
			}
			if(json_var.find("undp") != json_var.end()){
				try{
					const auto& json_var_undp = json_var.at("undp");
					if (json_var_undp.is_string())
					    tushare_basic_t_var.undp = DoubleConvertor::convert(json_var_undp.get<std::string>());
					else
					    json_var_undp.get_to(tushare_basic_t_var.undp);
				}catch(const std::exception& e){
					ERR("Convert \"undp\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"undp\" not found in json!");
				return false;
			}
			if(json_var.find("perundp") != json_var.end()){
				try{
					const auto& json_var_perundp = json_var.at("perundp");
					if (json_var_perundp.is_string())
					    tushare_basic_t_var.perundp = DoubleConvertor::convert(json_var_perundp.get<std::string>());
					else
					    json_var_perundp.get_to(tushare_basic_t_var.perundp);
				}catch(const std::exception& e){
					ERR("Convert \"perundp\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"perundp\" not found in json!");
				return false;
			}
			if(json_var.find("rev") != json_var.end()){
				try{
					const auto& json_var_rev = json_var.at("rev");
					if (json_var_rev.is_string())
					    tushare_basic_t_var.rev = DoubleConvertor::convert(json_var_rev.get<std::string>());
					else
					    json_var_rev.get_to(tushare_basic_t_var.rev);
				}catch(const std::exception& e){
					ERR("Convert \"rev\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"rev\" not found in json!");
				return false;
			}
			if(json_var.find("profit") != json_var.end()){
				try{
					const auto& json_var_profit = json_var.at("profit");
					if (json_var_profit.is_string())
					    tushare_basic_t_var.profit = DoubleConvertor::convert(json_var_profit.get<std::string>());
					else
					    json_var_profit.get_to(tushare_basic_t_var.profit);
				}catch(const std::exception& e){
					ERR("Convert \"profit\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"profit\" not found in json!");
				return false;
			}
			if(json_var.find("gpr") != json_var.end()){
				try{
					const auto& json_var_gpr = json_var.at("gpr");
					if (json_var_gpr.is_string())
					    tushare_basic_t_var.gpr = DoubleConvertor::convert(json_var_gpr.get<std::string>());
					else
					    json_var_gpr.get_to(tushare_basic_t_var.gpr);
				}catch(const std::exception& e){
					ERR("Convert \"gpr\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"gpr\" not found in json!");
				return false;
			}
			if(json_var.find("npr") != json_var.end()){
				try{
					const auto& json_var_npr = json_var.at("npr");
					if (json_var_npr.is_string())
					    tushare_basic_t_var.npr = DoubleConvertor::convert(json_var_npr.get<std::string>());
					else
					    json_var_npr.get_to(tushare_basic_t_var.npr);
				}catch(const std::exception& e){
					ERR("Convert \"npr\" to \"double\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"npr\" not found in json!");
				return false;
			}
			if(json_var.find("holders") != json_var.end()){
				try{
					const auto& json_var_holders = json_var.at("holders");
					if (json_var_holders.is_string())
					    tushare_basic_t_var.holders = IntConvertor::convert(json_var_holders.get<std::string>());
					else
					    json_var_holders.get_to(tushare_basic_t_var.holders);
				}catch(const std::exception& e){
					ERR("Convert \"holders\" to \"int\" fail! e={:}", e.what());
					throw e;
				}
			}else{
				ERR("\"holders\" not found in json!");
				return false;
			}
		}catch (const std::exception& e){
			ERR("parse json {:} \nfail:{:}", json_var.dump(4), e.what());
			return false;
		}
		return true;
	}
	/* to json */
	static bool to_json(nlohmann::json& json_var, const tushare_basic_t& tushare_basic_t_var){
		try{
			json_var["code"] = tushare_basic_t_var.code;
			json_var["name"] = tushare_basic_t_var.name;
			json_var["industry"] = tushare_basic_t_var.industry;
			json_var["area"] = tushare_basic_t_var.area;
			json_var["pe"] = tushare_basic_t_var.pe;
			json_var["outstanding"] = tushare_basic_t_var.outstanding;
			json_var["totals"] = tushare_basic_t_var.totals;
			json_var["totalAssets"] = tushare_basic_t_var.totalAssets;
			json_var["liquidAssets"] = tushare_basic_t_var.liquidAssets;
			json_var["fixedAssets"] = tushare_basic_t_var.fixedAssets;
			json_var["reserved"] = tushare_basic_t_var.reserved;
			json_var["reservedPerShare"] = tushare_basic_t_var.reservedPerShare;
			json_var["esp"] = tushare_basic_t_var.esp;
			json_var["bvps"] = tushare_basic_t_var.bvps;
			json_var["pb"] = tushare_basic_t_var.pb;
			json_var["timeToMarket"] = tushare_basic_t_var.timeToMarket;
			json_var["undp"] = tushare_basic_t_var.undp;
			json_var["perundp"] = tushare_basic_t_var.perundp;
			json_var["rev"] = tushare_basic_t_var.rev;
			json_var["profit"] = tushare_basic_t_var.profit;
			json_var["gpr"] = tushare_basic_t_var.gpr;
			json_var["npr"] = tushare_basic_t_var.npr;
			json_var["holders"] = tushare_basic_t_var.holders;
		}catch (const std::exception& e){
		ERR("to json {:} \nfail:{:}", json_var.dump(4), e.what());
			return false;
		}
		return true;
	}

	bool operator ==(const tushare_basic_t& d) const
	{
		if (code == d.code &&
			name == d.name &&
			industry == d.industry &&
			area == d.area &&
			pe == d.pe &&
			outstanding == d.outstanding &&
			totals == d.totals &&
			totalAssets == d.totalAssets &&
			liquidAssets == d.liquidAssets &&
			fixedAssets == d.fixedAssets &&
			reserved == d.reserved &&
			reservedPerShare == d.reservedPerShare &&
			esp == d.esp &&
			bvps == d.bvps &&
			pb == d.pb &&
			timeToMarket == d.timeToMarket &&
			undp == d.undp &&
			perundp == d.perundp &&
			rev == d.rev &&
			profit == d.profit &&
			gpr == d.gpr &&
			npr == d.npr &&
			holders == d.holders)
		{
			return true;
		}
		return false;
	}

	bool operator !=(const tushare_basic_t& d) const
	{
		return !((*this)==d);
	}

};// struct tushare_basic_t
} // namespace S4


        /* Tester */
        inline int tushare_basic_t_tester() {

            //std::ifstream i("G:/work2t/99_s3/s4/./json_template/tushare_basic_t.json");
            std::string i("{    \"__assign_type_fields__\": {        \"code\": \"pureCodeI_t\",        \"timeToMarket\":\"time_date_t\"    },    \"__sqlite_capable__\" : true,    \"__sqlite_primary__\" : \"code\",    \"code\": 600001,    \"name\": \"\",    \"industry\": \"\",    \"area\": \"\",    \"pe\": 0.0,    \"outstanding\": 0.0,    \"totals\": 0.0,    \"totalAssets\": 0.0,    \"liquidAssets\": 0.0,    \"fixedAssets\": 0.0,    \"reserved\": 0.0,    \"reservedPerShare\": 0.0,    \"esp\": 0.0,    \"bvps\": 0.0,    \"pb\": 0.0,    \"timeToMarket\": 0,    \"undp\": 0.0,    \"perundp\": 0.0,    \"rev\": 0.0,    \"profit\": 0.0,    \"gpr\": 0.0,    \"npr\": 0.0,    \"holders\": 0}");
            nlohmann::json json_var;
            //i >> json_var; //from file
            json_var = nlohmann::json::parse(i);  //from string

            S4::tushare_basic_t tushare_basic_t_var;

            if(!S4::tushare_basic_t::from_json(json_var, tushare_basic_t_var)){
                INFO("S4::tushare_basic_t::from_json fail!");
                return -1;
            }

            nlohmann::json j_out;
            if(!S4::tushare_basic_t::to_json(j_out, tushare_basic_t_var)){
                INFO("S4::tushare_basic_t::to_json fail!");
                return -1;
            }

            INFO("{:}", j_out.dump(4));

            return 0;
        }

        