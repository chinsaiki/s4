/*
* DON'T TOUCH!
* This file is generated by python script AUTOMATICALLY!
*
* Generated base on: ./json_template\sina_today_t.json
* Type name: sina_today_t
* Tester:    int sina_today_t_tester();
*
* Json keep-word: 
    "__default_value_fields__": [], # Take value in .json file as the default value of cpp variable
    "__optional_fields__": [], # Not require to present to .json file, but always in cpp struct
    "__assign_type_fields__": {"field":"cpp-type"}, # Assign specal cpp-type of field, but not infer automatically as default.
    "__assign_enum_fields__": {"field":"enum-type"}, # Assign specal enum-type of field, but not infer automatically as default.
                              enum-type need have implemented <enum-type>_toSting() & <enum-type>_fromString() functions.
    "__assign_set_lists__": [], # Take list in .json file as std::set<>, but not std::vector<> as default
    "__cpp_eq_eclude__":[],     # List of variables not involved in equal compare.
    "__comment__xxx":"", # Add comment line
    "__sqlite_capable__":"", # enable sqlite tableIO autogen
    "__sqlite_primary__":"", # assign the primary key of sqlite, if not assigned, first existing col of [ 'id', 'date', 'mktCode', 'datetime', 'code'] will be assigned automatically.
* Script author: ChinSaiki<chinsaiki@outlook.com>
*/
#pragma once


#include <assert.h>
#include "common/s4json_util.h"
#include "common/s4logger.h"
#include "types/s4type.h"

#include <set>
#include <list>
#include <vector>

namespace S4 {

/* type */
struct sina_today_t {
	std::string symbol;	//	sh688981
	std::string code;	//	688981
	std::string name;	//	ÖÐÐ¾¹ú¼Ê
	std::string trade;	//	55.170
	double pricechange;	//	-0.83
	double changepercent;	//	-1.482
	std::string buy;	//	55.170
	std::string sell;	//	55.180
	std::string settlement;	//	56.000
	std::string open;	//	56.020
	std::string high;	//	56.150
	std::string low;	//	55.050
	int volume;	//	26114656
	int amount;	//	1445777487
	std::string ticktime;	//	15:29:59
	double per;	//	82.343
	double pb;	//	4.324
	double mktcap;	//	43590427.323642
	double nmc;	//	6044717.601
	double turnoverratio;	//	2.38348

	/* from json */
	static bool from_json(const nlohmann::json& json_var, sina_today_t& sina_today_t_var){
		try{
			try{
				sina_today_t_var.symbol = json_var.at("symbol").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "symbol", e.what());
				throw e;
			}
			try{
				sina_today_t_var.code = json_var.at("code").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "code", e.what());
				throw e;
			}
			try{
				sina_today_t_var.name = json_var.at("name").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "name", e.what());
				throw e;
			}
			try{
				sina_today_t_var.trade = json_var.at("trade").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "trade", e.what());
				throw e;
			}
			try{
				sina_today_t_var.pricechange = json_var.at("pricechange").get<double>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "pricechange", e.what());
				throw e;
			}
			try{
				sina_today_t_var.changepercent = json_var.at("changepercent").get<double>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "changepercent", e.what());
				throw e;
			}
			try{
				sina_today_t_var.buy = json_var.at("buy").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "buy", e.what());
				throw e;
			}
			try{
				sina_today_t_var.sell = json_var.at("sell").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "sell", e.what());
				throw e;
			}
			try{
				sina_today_t_var.settlement = json_var.at("settlement").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "settlement", e.what());
				throw e;
			}
			try{
				sina_today_t_var.open = json_var.at("open").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "open", e.what());
				throw e;
			}
			try{
				sina_today_t_var.high = json_var.at("high").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "high", e.what());
				throw e;
			}
			try{
				sina_today_t_var.low = json_var.at("low").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "low", e.what());
				throw e;
			}
			try{
				sina_today_t_var.volume = json_var.at("volume").get<int>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "volume", e.what());
				throw e;
			}
			try{
				sina_today_t_var.amount = json_var.at("amount").get<int>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "amount", e.what());
				throw e;
			}
			try{
				sina_today_t_var.ticktime = json_var.at("ticktime").get<std::string>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "ticktime", e.what());
				throw e;
			}
			try{
				sina_today_t_var.per = json_var.at("per").get<double>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "per", e.what());
				throw e;
			}
			try{
				sina_today_t_var.pb = json_var.at("pb").get<double>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "pb", e.what());
				throw e;
			}
			try{
				sina_today_t_var.mktcap = json_var.at("mktcap").get<double>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "mktcap", e.what());
				throw e;
			}
			try{
				sina_today_t_var.nmc = json_var.at("nmc").get<double>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "nmc", e.what());
				throw e;
			}
			try{
				sina_today_t_var.turnoverratio = json_var.at("turnoverratio").get<double>();
			}catch(const std::exception& e){
				ERR("{:} not found in json! e={:}", "turnoverratio", e.what());
				throw e;
			}
		}catch (const std::exception& e){
			ERR("parse json {:} \nfail:{:}", json_var.dump(4), e.what());
			return false;
		}
		return true;
	}
	/* to json */
	static bool to_json(nlohmann::json& json_var, const sina_today_t& sina_today_t_var){
		try{
			json_var["symbol"] = sina_today_t_var.symbol;
			json_var["code"] = sina_today_t_var.code;
			json_var["name"] = sina_today_t_var.name;
			json_var["trade"] = sina_today_t_var.trade;
			json_var["pricechange"] = sina_today_t_var.pricechange;
			json_var["changepercent"] = sina_today_t_var.changepercent;
			json_var["buy"] = sina_today_t_var.buy;
			json_var["sell"] = sina_today_t_var.sell;
			json_var["settlement"] = sina_today_t_var.settlement;
			json_var["open"] = sina_today_t_var.open;
			json_var["high"] = sina_today_t_var.high;
			json_var["low"] = sina_today_t_var.low;
			json_var["volume"] = sina_today_t_var.volume;
			json_var["amount"] = sina_today_t_var.amount;
			json_var["ticktime"] = sina_today_t_var.ticktime;
			json_var["per"] = sina_today_t_var.per;
			json_var["pb"] = sina_today_t_var.pb;
			json_var["mktcap"] = sina_today_t_var.mktcap;
			json_var["nmc"] = sina_today_t_var.nmc;
			json_var["turnoverratio"] = sina_today_t_var.turnoverratio;
		}catch (const std::exception& e){
		ERR("to json {:} \nfail:{:}", json_var.dump(4), e.what());
			return false;
		}
		return true;
	}

	bool operator ==(const sina_today_t& d) const
	{
		if (symbol == d.symbol &&
			code == d.code &&
			name == d.name &&
			trade == d.trade &&
			pricechange == d.pricechange &&
			changepercent == d.changepercent &&
			buy == d.buy &&
			sell == d.sell &&
			settlement == d.settlement &&
			open == d.open &&
			high == d.high &&
			low == d.low &&
			volume == d.volume &&
			amount == d.amount &&
			ticktime == d.ticktime &&
			per == d.per &&
			pb == d.pb &&
			mktcap == d.mktcap &&
			nmc == d.nmc &&
			turnoverratio == d.turnoverratio)
		{
			return true;
		}
		return false;
	}

	bool operator !=(const sina_today_t& d) const
	{
		return !((*this)==d);
	}

};// struct sina_today_t
} // namespace S4


        /* Tester */
        inline int sina_today_t_tester() {

            //std::ifstream i("G:/work2t/99_s3/s4/./json_template/sina_today_t.json");
            std::string i("{    \"symbol\": \"sh688981\",    \"code\": \"688981\",    \"name\": \"\u4e2d\u82af\u56fd\u9645\",    \"trade\": \"55.170\",    \"pricechange\": -0.83,    \"changepercent\": -1.482,    \"buy\": \"55.170\",    \"sell\": \"55.180\",    \"settlement\": \"56.000\",    \"open\": \"56.020\",    \"high\": \"56.150\",    \"low\": \"55.050\",    \"volume\": 26114656,    \"amount\": 1445777487,    \"ticktime\": \"15:29:59\",    \"per\": 82.343,    \"pb\": 4.324,    \"mktcap\": 43590427.323642,    \"nmc\": 6044717.601,    \"turnoverratio\": 2.38348}");
            nlohmann::json json_var;
            //i >> json_var; //from file
            json_var = nlohmann::json::parse(i);  //from string

            S4::sina_today_t sina_today_t_var;

            if(!S4::sina_today_t::from_json(json_var, sina_today_t_var)){
                INFO("S4::sina_today_t::from_json fail!");
                return -1;
            }

            nlohmann::json j_out;
            if(!S4::sina_today_t::to_json(j_out, sina_today_t_var)){
                INFO("S4::sina_today_t::to_json fail!");
                return -1;
            }

            INFO("{:}", j_out.dump(4));

            return 0;
        }

        