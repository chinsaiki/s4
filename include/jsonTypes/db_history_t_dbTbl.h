/*
* DON'T TOUCH!
* This file is generated by python script AUTOMATICALLY!
*
* Generated base on: {0}
* Type name: {1}
* Tester:    int {1}_tester();
*
* Json keep-word: 
    "__default_value_fields__": [], # Take value in .json file as the default value of cpp variable
    "__optional_fields__": [], # Not require to present to .json file, but always in cpp struct
    "__assign_type_fields__": {{"field":"cpp-type"}}, # Assign specal cpp-type of field, but not infer automatically as default
    "__assign_set_lists__": [], # Take list in .json file as std::set<>, but not std::vector<> as default
    "__comment__xxx":"", # Add comment line
    "__sqlite_capable__":"", # enable sqlite tableIO autogen
* Script author: ChenZaihui<chinsaiki@outlook.com>
*/
#pragma once


#include "types/s4type.h"
#include "db_sqlite/tableIO.h"
#include <SQLiteCpp/ExecuteMany.h>

#include "jsonTypes/db_history_t.h"

namespace S4 {
namespace sqlite {

class db_history_t_dbTbl : public tableIO_t<struct db_history_t>{
public:
    typedef struct db_history_t data_t;
	//db_history_t_dbTbl(const std::string name)
    //{
    //    set_name(name);
    //};
    
	virtual void set_name(const std::string& name) override {
        m_name = name;
        m_qurey_build = "CREATE TABLE if not exists " + m_name + K_COL;
        m_qurey_insert = "INSERT OR IGNORE INTO " + m_name + K_IN;
    }

    virtual const std::string & get_query_build(void) const override { return m_qurey_build;};

    virtual const std::string & get_query_insert(void) const override { return m_qurey_insert;};
    
    virtual void bind_query(SQLite::Statement& query, const std::vector<struct db_history_t>& data, size_t nb) override
    {
        const struct db_history_t & K_data = data[nb];
        SQLite::bind(query,
			K_data.rowid,
			K_data.stgName,
			K_data.id,
			K_data.tdxOrderId,
			K_data.insCode,
			K_data.time,
			K_data.datetime,
			K_data.optType,
			K_data.position,
			K_data.status,
			K_data.open_order,
			K_data.take_order,
			K_data.stop_order,
			K_data.close_order,
			K_data.open_deal,
			K_data.openVol,
			K_data.openVol_deal,
			K_data.openAmt_deal,
			K_data.close_deal,
			K_data.closeVol,
			K_data.closeVol_deal,
			K_data.closeAmt_deal,
			K_data.commission,
			K_data.stamp_duty,
			K_data.transfer_fee,
			K_data.other_fees,
			K_data.remarks);
    }

    //warning: not clear data inside, but append DB.data to it
    virtual void load_query(SQLite::Statement& query, std::vector<db_history_t>& data) override
    {
        struct db_history_t K_data;
        K_data.rowid = query.getColumn(0).getInt64();
		K_data.stgName = query.getColumn(1).getString();
		K_data.id = query.getColumn(2).getInt64();
		K_data.tdxOrderId = query.getColumn(3).getInt64();
		K_data.insCode = query.getColumn(4).getString();
		K_data.time = query.getColumn(5).getInt64();
		K_data.datetime = query.getColumn(6).getString();
		K_data.optType = query.getColumn(7).getString();
		K_data.position = query.getColumn(8).getString();
		K_data.status = query.getColumn(9).getString();
		K_data.open_order = query.getColumn(10).getInt64();
		K_data.take_order = query.getColumn(11).getInt64();
		K_data.stop_order = query.getColumn(12).getInt64();
		K_data.close_order = query.getColumn(13).getInt64();
		K_data.open_deal = query.getColumn(14).getInt64();
		K_data.openVol = query.getColumn(15).getInt64();
		K_data.openVol_deal = query.getColumn(16).getInt64();
		K_data.openAmt_deal = query.getColumn(17).getDouble();
		K_data.close_deal = query.getColumn(18).getInt64();
		K_data.closeVol = query.getColumn(19).getInt64();
		K_data.closeVol_deal = query.getColumn(20).getInt64();
		K_data.closeAmt_deal = query.getColumn(21).getDouble();
		K_data.commission = query.getColumn(22).getDouble();
		K_data.stamp_duty = query.getColumn(23).getDouble();
		K_data.transfer_fee = query.getColumn(24).getDouble();
		K_data.other_fees = query.getColumn(25).getDouble();
		K_data.remarks = query.getColumn(26).getString();
        data.push_back(std::move(K_data));
    }

private:
	//std::string m_name;
    std::string m_qurey_build;
    std::string m_qurey_insert;
private:

const std::string K_COL =
    "( "
        "rowid	INTEGER, "
        "stgName	TEXT, "
        "id	INTEGER, "
        "tdxOrderId	INTEGER, "
        "insCode	TEXT, "
        "time	INTEGER, "
        "datetime	TEXT, "
        "optType	TEXT, "
        "position	TEXT, "
        "status	TEXT, "
        "open_order	INTEGER, "
        "take_order	INTEGER, "
        "stop_order	INTEGER, "
        "close_order	INTEGER, "
        "open_deal	INTEGER, "
        "openVol	INTEGER, "
        "openVol_deal	INTEGER, "
        "openAmt_deal	DOUBLE, "
        "close_deal	INTEGER, "
        "closeVol	INTEGER, "
        "closeVol_deal	INTEGER, "
        "closeAmt_deal	DOUBLE, "
        "commission	DOUBLE, "
        "stamp_duty	DOUBLE, "
        "transfer_fee	DOUBLE, "
        "other_fees	DOUBLE, "
        "remarks	TEXT, "

        "PRIMARY KEY(id)"
    ")";



const std::string K_IN =
    "("
    "rowid, stgName, id, tdxOrderId, insCode, time, datetime, optType, position, status, open_order, take_order, stop_order, close_order, open_deal, openVol, openVol_deal, openAmt_deal, close_deal, closeVol, closeVol_deal, closeAmt_deal, commission, stamp_duty, transfer_fee, other_fees, remarks"
    ") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"
;


};

}//namespace sqlite
}//namespace S4
