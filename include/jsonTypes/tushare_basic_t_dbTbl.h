/*
* DON'T TOUCH!
* This file is generated by python script AUTOMATICALLY!
*
* Generated base on: {0}
* Type name: {1}
* Tester:    int {1}_tester();
*
* Json keep-word: 
    "__default_value_fields__": [], # Take value in .json file as the default value of cpp variable
    "__optional_fields__": [], # Not require to present to .json file, but always in cpp struct
    "__assign_type_fields__": {{"field":"cpp-type"}}, # Assign specal cpp-type of field, but not infer automatically as default.
    "__assign_enum_fields__": {{"field":"enum-type"}}, # Assign specal enum-type of field, but not infer automatically as default.
                              enum-type need have implemented _toSting() & _fromString() functions.
    "__assign_set_lists__": [], # Take list in .json file as std::set<>, but not std::vector<> as default
    "__comment__xxx":"", # Add comment line
    "__sqlite_capable__":"", # enable sqlite tableIO autogen
    "__sqlite_primary__":"", # assign the primary key of sqlite, if not assigned, first existing col of [ 'id', 'date', 'mktCode', 'datetime', 'code'] will be assigned automatically.
* Script author: ChinSaiki<chinsaiki@outlook.com>
*/
#pragma once


#include "types/s4type.h"
#include "db_sqlite/tableIO.h"
#include <SQLiteCpp/ExecuteMany.h>

#include "jsonTypes/tushare_basic_t.h"

namespace S4 {
namespace sqlite {

class tushare_basic_t_dbTbl : public tableIO_t<struct tushare_basic_t>{
public:
    typedef struct tushare_basic_t data_t;
	//tushare_basic_t_dbTbl(const std::string name)
    //{
    //    set_name(name);
    //};
    
	virtual void set_name(const std::string& name) override {
        m_name = name;
        m_qurey_build = "CREATE TABLE if not exists " + m_name + K_COL;
        m_qurey_insert = "INSERT OR IGNORE INTO " + m_name + K_IN;
    }

    virtual const std::string & get_query_build(void) const override { return m_qurey_build;};

    virtual const std::string & get_query_insert(void) const override { return m_qurey_insert;};
    
    virtual void bind_query(SQLite::Statement& query, const std::vector<struct tushare_basic_t>& data, size_t nb) override
    {
        const struct tushare_basic_t & K_data = data[nb];
        query.bind(1, K_data.code);
		query.bind(2, K_data.name);
		query.bind(3, K_data.industry);
		query.bind(4, K_data.area);
		query.bind(5, K_data.pe);
		query.bind(6, K_data.outstanding);
		query.bind(7, K_data.totals);
		query.bind(8, K_data.totalAssets);
		query.bind(9, K_data.liquidAssets);
		query.bind(10, K_data.fixedAssets);
		query.bind(11, K_data.reserved);
		query.bind(12, K_data.reservedPerShare);
		query.bind(13, K_data.esp);
		query.bind(14, K_data.bvps);
		query.bind(15, K_data.pb);
		query.bind(16, K_data.timeToMarket);
		query.bind(17, K_data.undp);
		query.bind(18, K_data.perundp);
		query.bind(19, K_data.rev);
		query.bind(20, K_data.profit);
		query.bind(21, K_data.gpr);
		query.bind(22, K_data.npr);
		query.bind(23, K_data.holders);
    }

    //warning: not clear data inside, but append DB.data to it
    virtual void load_query(SQLite::Statement& query, std::vector<tushare_basic_t>& data) override
    {
        struct tushare_basic_t K_data;
        K_data.code = (pureCodeI_t)query.getColumn(0).getInt64();
		K_data.name = (std::string)query.getColumn(1).getString();
		K_data.industry = (std::string)query.getColumn(2).getString();
		K_data.area = (std::string)query.getColumn(3).getString();
		K_data.pe = (double)query.getColumn(4).getDouble();
		K_data.outstanding = (double)query.getColumn(5).getDouble();
		K_data.totals = (double)query.getColumn(6).getDouble();
		K_data.totalAssets = (double)query.getColumn(7).getDouble();
		K_data.liquidAssets = (double)query.getColumn(8).getDouble();
		K_data.fixedAssets = (double)query.getColumn(9).getDouble();
		K_data.reserved = (double)query.getColumn(10).getDouble();
		K_data.reservedPerShare = (double)query.getColumn(11).getDouble();
		K_data.esp = (double)query.getColumn(12).getDouble();
		K_data.bvps = (double)query.getColumn(13).getDouble();
		K_data.pb = (double)query.getColumn(14).getDouble();
		K_data.timeToMarket = (time_date_t)query.getColumn(15).getInt64();
		K_data.undp = (double)query.getColumn(16).getDouble();
		K_data.perundp = (double)query.getColumn(17).getDouble();
		K_data.rev = (double)query.getColumn(18).getDouble();
		K_data.profit = (double)query.getColumn(19).getDouble();
		K_data.gpr = (double)query.getColumn(20).getDouble();
		K_data.npr = (double)query.getColumn(21).getDouble();
		K_data.holders = (int)query.getColumn(22).getInt64();
        data.push_back(std::move(K_data));
    }

private:
	//std::string m_name;
    std::string m_qurey_build;
    std::string m_qurey_insert;
private:

const std::string K_COL =
    "( "
        "code	INTEGER, "
        "name	TEXT, "
        "industry	TEXT, "
        "area	TEXT, "
        "pe	DOUBLE, "
        "outstanding	DOUBLE, "
        "totals	DOUBLE, "
        "totalAssets	DOUBLE, "
        "liquidAssets	DOUBLE, "
        "fixedAssets	DOUBLE, "
        "reserved	DOUBLE, "
        "reservedPerShare	DOUBLE, "
        "esp	DOUBLE, "
        "bvps	DOUBLE, "
        "pb	DOUBLE, "
        "timeToMarket	INTEGER, "
        "undp	DOUBLE, "
        "perundp	DOUBLE, "
        "rev	DOUBLE, "
        "profit	DOUBLE, "
        "gpr	DOUBLE, "
        "npr	DOUBLE, "
        "holders	INTEGER, "

        "PRIMARY KEY(code)"
    ")";



const std::string K_IN =
    "("
    "code, name, industry, area, pe, outstanding, totals, totalAssets, liquidAssets, fixedAssets, reserved, reservedPerShare, esp, bvps, pb, timeToMarket, undp, perundp, rev, profit, gpr, npr, holders"
    ") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"
;


};

}//namespace sqlite
}//namespace S4
