/*
* DON'T TOUCH!
* This file is generated by python script AUTOMATICALLY!
*
* Generated base on: {0}
* Type name: {1}
* Tester:    int {1}_tester();
*
* Json keep-word: 
    "__default_value_fields__": [], # Take value in .json file as the default value of cpp variable
    "__optional_fields__": [], # Not require to present to .json file, but always in cpp struct
    "__assign_type_fields__": {{"field":"cpp-type"}}, # Assign specal cpp-type of field, but not infer automatically as default.
    "__assign_enum_fields__": {{"field":"enum-type"}}, # Assign specal enum-type of field, but not infer automatically as default.
                              enum-type need have implemented <enum-type>_toSting() & <enum-type>_fromString() functions.
    "__assign_set_lists__": [], # Take list in .json file as std::set<>, but not std::vector<> as default
    "__comment__xxx":"", # Add comment line
    "__sqlite_capable__":"", # enable sqlite tableIO autogen
    "__sqlite_primary__":"", # assign the primary key of sqlite, if not assigned, first existing col of [ 'id', 'date', 'mktCode', 'datetime', 'code'] will be assigned automatically.
* Script author: ChinSaiki<chinsaiki@outlook.com>
*/
#pragma once


#include "types/s4type.h"
#include "db_sqlite/tableIO.h"
#include <SQLiteCpp/ExecuteMany.h>

#include "s4infSnap.h"

namespace S4 {
namespace sqlite {

class s4infSnap_tableIO : public tableIO_t<std::shared_ptr<infSnap_t>>{
public:
    typedef struct tdx_snap_t data_t;
	//s4infSnap_tableIO(const std::string name)
    //{
    //    set_name(name);
    //};
    
	virtual void set_name(const std::string& name) override {
        m_name = name;
        m_qurey_build = "CREATE TABLE if not exists " + m_name + K_COL;
        m_qurey_insert = "INSERT OR IGNORE INTO " + m_name + K_IN;
    }

    virtual const std::string & get_query_build(void) const override { return m_qurey_build;};

    virtual const std::string & get_query_insert(void) const override { return m_qurey_insert;};
    
    virtual void bind_query(SQLite::Statement& query, const std::vector<std::shared_ptr<infSnap_t>>& data, size_t nb) override
    {
        const std::shared_ptr<infSnap_t> & K_data = data[nb];
        query.bind(1, K_data->_date);

		query.bind(2, K_data->_MinmuSec);

		query.bind(3, K_data->_time);

		query.bind(4, K_data->mktCode);

		query.bind(5, K_data->active1);

		query.bind(6, K_data->price);

		query.bind(7, K_data->last_close);

		query.bind(8, K_data->open);

		query.bind(9, K_data->high);

		query.bind(10, K_data->low);

		query.bind(11, K_data->ms);

		query.bind(12, K_data->vol);

		query.bind(13, K_data->cur_vol);

		query.bind(14, K_data->amount);

		query.bind(15, K_data->s_vol);

		query.bind(16, K_data->b_vol);

		query.bind(17, K_data->bid1);

		query.bind(18, K_data->ask1);

		query.bind(19, K_data->bid_vol1);

		query.bind(20, K_data->ask_vol1);

		query.bind(21, K_data->bid2);

		query.bind(22, K_data->ask2);

		query.bind(23, K_data->bid_vol2);

		query.bind(24, K_data->ask_vol2);

		query.bind(25, K_data->bid3);

		query.bind(26, K_data->ask3);

		query.bind(27, K_data->bid_vol3);

		query.bind(28, K_data->ask_vol3);

		query.bind(29, K_data->bid4);

		query.bind(30, K_data->ask4);

		query.bind(31, K_data->bid_vol4);

		query.bind(32, K_data->ask_vol4);

		query.bind(33, K_data->bid5);

		query.bind(34, K_data->ask5);

		query.bind(35, K_data->bid_vol5);

		query.bind(36, K_data->ask_vol5);

		query.bind(37, K_data->reversed_bytes0);

		query.bind(38, K_data->reversed_bytes1);

		query.bind(39, K_data->reversed_bytes2);

		query.bind(40, K_data->reversed_bytes3);

		query.bind(41, K_data->reversed_bytes4);

		query.bind(42, K_data->reversed_bytes5);

		query.bind(43, K_data->reversed_bytes6);

		query.bind(44, K_data->reversed_bytes7);

		query.bind(45, K_data->reversed_bytes8);

		query.bind(46, K_data->reversed_bytes9);

		query.bind(47, K_data->active2);

		query.bind(48, K_data->lcl_time);

		query.bind(49, utc_to_str(K_data->lcl_time));

		query.bind(50, "2");
    }

    //warning: not clear data inside, but append DB.data to it
    virtual void load_query(SQLite::Statement& query, std::vector<std::shared_ptr<infSnap_t>>& data) override
    {
        std::shared_ptr<infSnap_t> K_data = std::make_shared<infSnap_t>();
        K_data->_date = (time_date_t)query.getColumn(0).getInt64();
		K_data->_MinmuSec = (time_minuSec_t)query.getColumn(1).getInt64();
		K_data->_time = (time_utcSec_t)query.getColumn(2).getInt64();
		K_data->mktCode = (mktCodeI_t)query.getColumn(3).getInt64();
		K_data->active1 = (uint16_t)query.getColumn(4).getInt64();
		K_data->price = (price_t)query.getColumn(5).getInt64();
		K_data->last_close = (price_t)query.getColumn(6).getInt64();
		K_data->open = (price_t)query.getColumn(7).getInt64();
		K_data->high = (price_t)query.getColumn(8).getInt64();
		K_data->low = (price_t)query.getColumn(9).getInt64();
		K_data->ms = (int)query.getColumn(10).getInt64();
		K_data->vol = (vol_tdx_t)query.getColumn(11).getInt64();
		K_data->cur_vol = (vol_tdx_t)query.getColumn(12).getInt64();
		K_data->amount = (amount_t)query.getColumn(13).getDouble();
		K_data->s_vol = (vol_tdx_t)query.getColumn(14).getInt64();
		K_data->b_vol = (vol_tdx_t)query.getColumn(15).getInt64();
		K_data->bid1 = (price_t)query.getColumn(16).getInt64();
		K_data->ask1 = (price_t)query.getColumn(17).getInt64();
		K_data->bid_vol1 = (vol_tdx_t)query.getColumn(18).getInt64();
		K_data->ask_vol1 = (vol_tdx_t)query.getColumn(19).getInt64();
		K_data->bid2 = (price_t)query.getColumn(20).getInt64();
		K_data->ask2 = (price_t)query.getColumn(21).getInt64();
		K_data->bid_vol2 = (vol_tdx_t)query.getColumn(22).getInt64();
		K_data->ask_vol2 = (vol_tdx_t)query.getColumn(23).getInt64();
		K_data->bid3 = (price_t)query.getColumn(24).getInt64();
		K_data->ask3 = (price_t)query.getColumn(25).getInt64();
		K_data->bid_vol3 = (vol_tdx_t)query.getColumn(26).getInt64();
		K_data->ask_vol3 = (vol_tdx_t)query.getColumn(27).getInt64();
		K_data->bid4 = (price_t)query.getColumn(28).getInt64();
		K_data->ask4 = (price_t)query.getColumn(29).getInt64();
		K_data->bid_vol4 = (vol_tdx_t)query.getColumn(30).getInt64();
		K_data->ask_vol4 = (vol_tdx_t)query.getColumn(31).getInt64();
		K_data->bid5 = (price_t)query.getColumn(32).getInt64();
		K_data->ask5 = (price_t)query.getColumn(33).getInt64();
		K_data->bid_vol5 = (vol_tdx_t)query.getColumn(34).getInt64();
		K_data->ask_vol5 = (vol_tdx_t)query.getColumn(35).getInt64();
		K_data->reversed_bytes0 = (uint32_t)query.getColumn(36).getInt64();
		K_data->reversed_bytes1 = (uint32_t)query.getColumn(37).getInt64();
		K_data->reversed_bytes2 = (uint32_t)query.getColumn(38).getInt64();
		K_data->reversed_bytes3 = (uint32_t)query.getColumn(39).getInt64();
		K_data->reversed_bytes4 = (uint16_t)query.getColumn(40).getInt64();
		K_data->reversed_bytes5 = (uint32_t)query.getColumn(41).getInt64();
		K_data->reversed_bytes6 = (uint32_t)query.getColumn(42).getInt64();
		K_data->reversed_bytes7 = (uint32_t)query.getColumn(43).getInt64();
		K_data->reversed_bytes8 = (uint32_t)query.getColumn(44).getInt64();
		K_data->reversed_bytes9 = (uint16_t)query.getColumn(45).getInt64();
		K_data->active2 = (uint16_t)query.getColumn(46).getInt64();
		K_data->lcl_time = (time_utcSec_t)query.getColumn(47).getInt64();

        utc_to_date(K_data->lcl_time, &K_data->lcl_minu);
		// K_data->lcl_time_str = (std::string)query.getColumn(48).getString();
		// K_data->VERSION = (int)query.getColumn(49).getInt64();
        data.push_back(std::move(K_data));
    }

private:
	//std::string m_name;
    std::string m_qurey_build;
    std::string m_qurey_insert;
private:

const std::string K_COL =
    "( "
        "date	INTEGER, "
        "minuSec	INTEGER, "
        "time	INTEGER, "
        "mktCode	INTEGER, "
        "active1	INTEGER, "
        "price	INTEGER, "
        "last_close	INTEGER, "
        "open	INTEGER, "
        "high	INTEGER, "
        "low	INTEGER, "
        "ms	INTEGER, "
        "vol	INTEGER, "
        "cur_vol	INTEGER, "
        "amount	DOUBLE, "
        "s_vol	INTEGER, "
        "b_vol	INTEGER, "
        "bid1	INTEGER, "
        "ask1	INTEGER, "
        "bid_vol1	INTEGER, "
        "ask_vol1	INTEGER, "
        "bid2	INTEGER, "
        "ask2	INTEGER, "
        "bid_vol2	INTEGER, "
        "ask_vol2	INTEGER, "
        "bid3	INTEGER, "
        "ask3	INTEGER, "
        "bid_vol3	INTEGER, "
        "ask_vol3	INTEGER, "
        "bid4	INTEGER, "
        "ask4	INTEGER, "
        "bid_vol4	INTEGER, "
        "ask_vol4	INTEGER, "
        "bid5	INTEGER, "
        "ask5	INTEGER, "
        "bid_vol5	INTEGER, "
        "ask_vol5	INTEGER, "
        "reversed_bytes0	INTEGER, "
        "reversed_bytes1	INTEGER, "
        "reversed_bytes2	INTEGER, "
        "reversed_bytes3	INTEGER, "
        "reversed_bytes4	INTEGER, "
        "reversed_bytes5	INTEGER, "
        "reversed_bytes6	INTEGER, "
        "reversed_bytes7	INTEGER, "
        "reversed_bytes8	INTEGER, "
        "reversed_bytes9	INTEGER, "
        "active2	INTEGER, "
        "lcl_time	INTEGER, "
        "lcl_time_str	TEXT, "
        "VERSION	INTEGER, "

        "PRIMARY KEY(time)"
    ")";



const std::string K_IN =
    "("
    "date, minuSec, time, mktCode, active1, price, last_close, open, high, low, ms, vol, cur_vol, amount, s_vol, b_vol, bid1, ask1, bid_vol1, ask_vol1, bid2, ask2, bid_vol2, ask_vol2, bid3, ask3, bid_vol3, ask_vol3, bid4, ask4, bid_vol4, ask_vol4, bid5, ask5, bid_vol5, ask_vol5, reversed_bytes0, reversed_bytes1, reversed_bytes2, reversed_bytes3, reversed_bytes4, reversed_bytes5, reversed_bytes6, reversed_bytes7, reversed_bytes8, reversed_bytes9, active2, lcl_time, lcl_time_str, VERSION"
    ") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"
;


};

}//namespace sqlite
}//namespace S4
